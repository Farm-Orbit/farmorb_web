---
alwaysApply: true
---

# FarmOrbit Project Rules

## Code Style & Architecture

### TypeScript Configuration
- Allow `any` type in some cases by setting `noImplicitAny` and `strictNullChecks` to `false`
- Use `strictPropertyInitialization: false` for flexibility
- Exclude test files from TypeScript compilation

### Component Architecture
- Use layer-based architecture (components, services, store, types)
- Prefer functional components with hooks
- Use `"use client"` directive for client-side components
- Wrap components that use `useSearchParams` in Suspense boundaries for Next.js 15 compatibility

### State Management
- Use Redux Toolkit for global state management
- Create custom hooks (useAuth, useFarms) for convenient state access
- Use async thunks for API calls
- Prioritize `error.error` over `error.message` in error handling

## API Integration

### Error Handling
- Always prioritize `error.error` over `error.message` from API responses
- Use `handleApiError` utility function for consistent error handling
- Show actual API errors to users instead of masking them
- Log API responses for debugging

### Token Management
- Use `js-cookie` for JWT token storage
- Store tokens in secure cookies with proper expiration
- Implement token refresh logic in API interceptors
- Clear tokens on logout and authentication failures

### API Client
- Use Axios with request/response interceptors
- Add Authorization header automatically for authenticated requests
- Handle 401 errors with automatic token refresh
- Log API requests and responses for debugging

## Testing

### Integration Testing Philosophy
- **NO MOCKING in Integration Tests**: Integration tests must test actual API integration
- Integration tests are the first point to discover if APIs work as expected
- Use real API calls to validate service layer functionality
- Test actual HTTP requests/responses, not mocked data
- Integration tests should fail if the API is broken or changed
- Only mock external services (not our own APIs) when necessary

### Test Validation Philosophy
- **Tests must validate expected behavior**: Tests should fail when functionality doesn't work as expected
- **Never accept empty results when expecting data**: If a test expects invitations and gets an empty array, the test should fail
- **Create test data to validate functionality**: Set up proper test scenarios with known data to verify expected outcomes
- **Assert on specific expected values**: Don't just check if arrays exist, verify they contain the expected data
- **Test the complete workflow**: Create data, perform actions, then verify the results match expectations
- **Fail fast on unexpected behavior**: If an API returns empty results when data should exist, the test must fail
- **Validate business logic**: Ensure tests verify that business rules are working correctly, not just that endpoints respond

### Cypress Testing
- Use `data-testid` attributes for all element selection
- Create reusable commands for common actions (signup, signin)
- Test actual functionality, not just form submission
- Show errors when APIs fail instead of hiding them
- Use UI navigation instead of direct URL navigation
- Log API responses and errors for debugging
- **DRY Principle**: Extract reusable test code into custom commands or helper functions
- Create reusable commands for repeated test patterns (form filling, API intercepts, assertions)
- Use `cypress/support/commands.ts` for custom commands that can be shared across test files
- Avoid duplicating test setup, form interactions, or assertion patterns

### Test Structure
- Use `before` hooks for user setup
- Use `beforeEach` hooks for test isolation
- Clear authentication state between tests
- Test error handling and user feedback
- **Integration tests**: Test real API integration without mocking
- **Unit tests**: Can use mocks for isolated component testing

## UI/UX

### Data Attributes
- Use `data-testid` for all interactive elements
- Follow naming convention: `component-action-element` (e.g., `farm-submit-button`)
- Add data-testid to all form inputs, buttons, and navigation elements

### Error Display
- Show validation errors in red text
- Display API errors prominently to users
- Use consistent error styling across components
- Clear errors when user starts typing

### Navigation
- Use sidebar navigation instead of direct URL navigation
- Implement proper route protection with AuthGuard
- Use Next.js router for programmatic navigation

## File Organization

### Component Structure
- Place components in appropriate directories (auth, farms, ui, form)
- Use index files for clean imports
- Separate concerns: components, services, types, hooks

### Naming Conventions
- Use PascalCase for components and types
- Use camelCase for functions and variables
- Use kebab-case for file names
- Use descriptive names that indicate purpose

## Security

### Authentication
- Implement JWT-based authentication
- Use secure cookie storage for tokens
- Implement proper logout functionality
- Protect routes with middleware and AuthGuard

### Input Validation
- Validate all form inputs on client side
- Sanitize user inputs before sending to API
- Show clear validation error messages
- Prevent form submission with invalid data

## Performance

### Code Splitting
- Use dynamic imports for large components
- Implement proper loading states
- Use Suspense boundaries for async components

### State Management
- Use Redux Toolkit for efficient state updates
- Implement proper loading and error states
- Avoid unnecessary re-renders with proper selectors

## Development Workflow

### Package Management
- **ALWAYS use Yarn** for all package management operations
- Use `yarn add`, `yarn remove`, `yarn install` instead of npm commands
- Use `yarn test`, `yarn build`, `yarn dev` for scripts
- Never use npm commands in this project

### Debugging
- Add comprehensive logging for API calls
- Log token storage and retrieval
- Show detailed error information
- Use console.log with emojis for easy identification

### Error Handling
- Never hide API errors from users
- Provide actionable error messages
- Implement graceful degradation
- Log errors for debugging purposes

## Specific Project Rules

### Farm Management
- Focus on core CRUD operations (Create, Read, Update, Delete)
- Remove unnecessary features like search, filters, and pagination for simplicity
- Use simple grid layout for farm listing
- Implement proper form validation for farm creation

### Authentication Flow
- Use reusable signup/signin commands in tests
- Handle authentication state properly
- Implement proper redirects after login/logout
- Clear authentication state when needed

### API Integration
- Match frontend response handling to backend API structure
- Use proper field names from API responses
- Handle different response structures gracefully
- Implement proper error handling for all API calls

## Integration Testing Best Practices

### Test Structure and Setup
- **Follow the same pattern as working tests**: When fixing failing tests, always reference and follow the exact structure of passing tests
- **Use const objects for test data**: Define test users as `const` objects with `firstName`/`lastName` (not `first_name`/`last_name`)
- **Create farms in individual tests**: Don't rely on shared `testFarm` variables; create farms within each test for isolation
- **Use proper type casting**: Use `(farm as any).id` for type safety when accessing farm IDs
- **Set tokens correctly**: Always call `TokenManager.setAccessToken()` and `TokenManager.setRefreshToken()` after login

### Business Logic Testing
- **Test real user flows**: Create proper multi-user scenarios where users perform actions they're authorized for
- **Validate authentication context**: Users can only perform actions they're authorized for (e.g., can't accept others' invitations)
- **Test both success and security boundaries**: Verify that security rules are enforced (e.g., access denied for unauthorized actions)
- **Use proper user switching**: When testing multi-user flows, properly switch authentication tokens between users

### API Contract Validation
- **Verify parameter types**: Ensure frontend passes the correct parameter types that backend expects
- **Check ID mappings**: Distinguish between different ID types (user_id vs farm_member_id vs invitation_id)
- **Validate error structures**: Understand how the API client transforms errors (e.g., `error.statusCode` vs `error.response.status`)
- **Test actual API endpoints**: Use real API calls to validate the complete request/response cycle

### Error Handling and Debugging
- **Add comprehensive logging**: Use console.log with emojis to track test flow and identify issues
- **Debug error structures**: Log the actual error objects to understand the response format
- **Test API endpoints directly**: Use Node.js scripts to test API endpoints independently when debugging
- **Validate business rules**: Ensure tests fail when business logic is violated (e.g., unauthorized access attempts)

### Test Development Process
- **Write one test case at a time**: Focus on getting the first test case to pass completely before moving to the next one
- **Verify each test passes**: Never move to the next test case until the current one runs successfully
- **Debug thoroughly**: If a test fails, debug and fix it completely before proceeding
- **Incremental development**: Build test coverage gradually, ensuring each step works before adding complexity

### Common Integration Test Patterns
- **Multi-user authentication flow**:
  1. Register User A and User B
  2. Login as User A, create farm, invite User B
  3. Switch to User B's token, accept invitation
  4. Switch back to User A's token, perform owner actions
- **Parameter validation**: Always verify that frontend passes the correct parameter types (user_id vs member_id)
- **Token management**: Properly set and clear tokens between different user contexts
- **Error expectation**: Test both success cases and expected failure cases (security boundaries)

## Dark Mode Theme Format

### UI Component Design Rules
- **Always use Tailwind CSS dark mode classes** for all UI components to ensure proper dark mode support
- **Follow the established theme format** with consistent color schemes across all components
- **Use semantic color classes** that automatically adapt to light/dark themes

### Required Dark Mode Classes
- **Background colors**: Use `bg-white dark:bg-gray-800` for cards and main backgrounds
- **Text colors**: Use `text-gray-900 dark:text-white` for primary text, `text-gray-600 dark:text-gray-400` for secondary text
- **Border colors**: Use `border-gray-200 dark:border-gray-700` for borders
- **Input fields**: Use `bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white`
- **Buttons**: Use `bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white`
- **Error states**: Use `text-red-600 dark:text-red-400` for error text, `bg-red-50 dark:bg-red-900/20` for error backgrounds
- **Success states**: Use `text-green-600 dark:text-green-400` for success text, `bg-green-50 dark:bg-green-900/20` for success backgrounds

### Component Structure Requirements
- **All components must support both light and dark modes**
- **Use consistent spacing and typography** with Tailwind classes
- **Ensure proper contrast ratios** in both light and dark themes
- **Test components in both themes** to verify proper appearance

### Theme Implementation Pattern
```tsx
// Example component structure
<div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
  <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
    Component Title
  </h2>
  <p className="text-gray-600 dark:text-gray-400 mb-4">
    Component description
  </p>
  <Button className="bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white">
    Action Button
  </Button>
</div>
```